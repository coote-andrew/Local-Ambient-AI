<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Recorder</title>
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        .recording { color: red; }
        .hidden { display: none; }
        .previous-recording {
            border: 1px solid #dee2e6;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 0.375rem;
            background-color: white;
        }
        .prompt-container {
            background-color: #f8f9fa;
            padding: 1.5rem;
            border-radius: 0.375rem;
            margin: 1.5rem 0;
            border: 1px solid #dee2e6;
        }
        .record-controls {
            text-align: center;
            margin: 2rem 0;
        }
        .record-btn {
            padding: 1rem 2rem;
            font-size: 1.25rem;
            margin: 0 0.5rem;
        }
        #recordButton {
            background-color: #198754;
            color: white;
        }
        #stopButton {
            background-color: #dc3545;
            color: white;
        }
        .summary-section {
            background-color: white;
            padding: 1rem;
            border-radius: 0.375rem;
            border: 1px solid #dee2e6;
        }
        body {
            background-color: #f8f9fa;
            padding: 2rem 0;
        }
        .session-info {
            background-color: #e9ecef;
            padding: 1rem;
            border-radius: 0.375rem;
            margin-bottom: 2rem;
        }
    </style>
    <!-- Include marked.js for markdown rendering -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
</head>
<body>
    <div class="container">
        <div class="session-info">
            <h3>Session Info</h3>
            <p class="mb-0"><strong>Doctor:</strong> {{ doctor }}  <strong>Hash:</strong> {{ hash_value }}</p>
        </div>

        <h1 class="text-center mb-4">Audio Recorder</h1>

        <div class="prompt-container">
            <div class="row mb-3">
                <div class="col-md-6">
                    <label for="llmModel" class="form-label">Select LLM Model:</label>
                    <select id="llmModel" class="form-select">
                        {% for model, is_default in llm_models %}
                            <option value="{{ model }}" {% if is_default %}selected{% endif %}>
                                {{ model }}{% if is_default %} (Default){% endif %}
                            </option>
                        {% endfor %}
                    </select>
                </div>
                <div class="col-md-6">
                    <label for="promptSelect" class="form-label">Select Prompt:</label>
                    <select id="promptSelect" class="form-select" onchange="updatePromptText()">
                        <option value="custom">Custom Prompt</option>
                        {% for prompt in prompts %}
                            <option value="{{ prompt[0] }}">
                                #{{ prompt[2] }} - {{ prompt[0][:100] }}...
                            </option>
                        {% endfor %}
                    </select>
                </div>
            </div>
            <div class="mb-3">
                <label for="prompt" class="form-label">Prompt Text:</label>
                <textarea id="prompt" class="form-control" rows="4">{{ prompts[0][0] if prompts else 'Enter custom prompt here...' }}</textarea>
                <div class="mt-2">
                    <button onclick="savePrompt(true)" class="btn btn-outline-primary btn-sm">Save prompt as Default for me</button>
                    <button onclick="savePrompt(false)" class="btn btn-outline-secondary btn-sm">Save as Additional Prompt</button>
                </div>
            </div>
        </div>

        <div class="record-controls">
            <button id="recordButton" class="btn record-btn">Start Recording</button>
            <button id="stopButton" class="btn record-btn" disabled>Stop Recording</button>
        </div>

        <div class="mt-3">
            <h4>Live Transcription:</h4>
            <div id="liveTranscript" class="border p-3 mb-3" style="max-height: 200px; overflow-y: auto;">
            </div>
        </div>

        <div id="audioOptions" class="text-center mt-2 hidden">
            <div class="previous-recording">
                <p><strong>Audio Options:</strong></p>
                <div class="btn-group">
                    <button onclick="downloadAudio()" class="btn btn-sm btn-outline-secondary">Download Audio</button>
                    <button onclick="showSaveConfirm()" class="btn btn-sm btn-outline-primary">Save to Server</button>
                </div>
            </div>
        </div>

        <div class="text-center mt-2">
            <p id="recordingTimer" class="mb-1">Recording Time: 0s</p>
            <p id="processingTimer" class="hidden mb-1">Processing Time: 0s</p>
            <p id="loading" class="hidden">Loading...</p>
        </div>

        <div id="result" class="hidden">
            <h3>Results:</h3>
            <div id="transcriptionResult"></div>
        </div>

    <div id="previousRecordings">
        <h3>Previous Recordings</h3>
        {% for rec in previous_recordings %}
        <div class="previous-recording">
            <p><strong>Version:</strong> {{ rec[0] }}
                <button onclick="copyTextFromElement(this.closest('.previous-recording').querySelector('.summary-section'))" class="btn btn-sm btn-outline-secondary">
                    Copy Summary
                </button>
            </p>
            <div class="summary-section">
                {{ rec[3] | markdown | safe }}
            </div>
            <details>
                <summary>Additional Information</summary>
                <p><strong>Date:</strong> {{ rec[5] }}</p>
                <p><strong>Model Used:</strong> {{ rec[4] }}</p>
                <p><strong>Prompt Used:</strong> {{ rec[1] }}</p>
                <details>
                    <summary>Raw Transcript</summary>
                    <p>{{ rec[2] }}</p>
                </details>
                <button 
                    onclick="retryTranscript(`{{ rec[2] | replace('`', '\\`') | safe }}`)" 
                    class="retry-btn btn btn-sm"
                >
                    Retry with current settings
                </button>
                {% if rec[6] %}
                    <p><em>Audio file saved locally</em></p>
                {% endif %}
            </details>
        </div>
        {% endfor %}
    </div>

    </div>

    <script>
        const CHUNK_INTERVAL = 30000; // 30 seconds in milliseconds
        const OVERLAP_DURATION = 2000; // 2 seconds overlap
        let lastChunkTime = 0;
        let mediaRecorder;
        let chunks = [];
        let recordingInterval;
        let processingTimerInterval;
        let recordingTime = 0;
        let processingTime = 0;
        const hash = '{{ hash_value }}';
        const doctor = '{{ doctor }}';
        let audioSaveConfirmed = false;
        let accumulatedTranscription = '';
        let debugChunkCounter = 0;
        let webmHeaderData = null;
        let isFirstChunk = true;
        let clusterStartTime = Date.now();

        function startRecordingTimer() {
            recordingTime = 0;
            document.getElementById('recordingTimer').textContent = `Recording Time: ${recordingTime}s`;
            recordingInterval = setInterval(() => {
                recordingTime++;
                document.getElementById('recordingTimer').textContent = `Recording Time: ${recordingTime}s`;
            }, 1000);
        }

        function stopRecordingTimer() {
            clearInterval(recordingInterval);
            document.getElementById('recordingTimer').textContent = `Recording Time: ${recordingTime}s`;
        }

        function startProcessingTimer() {
            processingTime = 0;
            document.getElementById('processingTimer').classList.remove('hidden');
            document.getElementById('processingTimer').textContent = `Processing Time: ${processingTime}s`;
            processingTimerInterval = setInterval(() => {
                processingTime++;
                document.getElementById('processingTimer').textContent = `Processing Time: ${processingTime}s`;
            }, 1000);
        }

        function stopProcessingTimer() {
            clearInterval(processingTimerInterval);
            document.getElementById('processingTimer').textContent = `Processing Time: ${processingTime}s`;
        }

        function stopTimers() {
            clearInterval(recordingInterval);
            clearInterval(processingTimerInterval);
        }

        function updatePromptText() {
            const select = document.getElementById('promptSelect');
            const promptArea = document.getElementById('prompt');
            if (select.value === 'custom') {
                promptArea.value = '';
                promptArea.removeAttribute('readonly');
            } else {
                promptArea.value = select.value;
                promptArea.setAttribute('readonly', true);
            }
        }

        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('recordButton').addEventListener('click', () => {
                // Clear any existing chunks before starting new recording
                chunks = [];
                startRecording();
            });

            document.getElementById('stopButton').addEventListener('click', () => {
                if (mediaRecorder && mediaRecorder.state === 'recording') {
                    console.log('Stop button clicked, stopping recording');
                    mediaRecorder.stop();
                    stopRecordingTimer();
                    document.getElementById('recordButton').disabled = false;
                    document.getElementById('stopButton').disabled = true;
                    document.getElementById('recordButton').classList.remove('recording');
                }
            });
        });

        async function extractWebMHeaders(blob) {
            const arrayBuffer = await blob.arrayBuffer();
            const dataView = new DataView(arrayBuffer);
            
            // Look for the first Cluster element (0x1F43B675)
            let offset = 0;
            while (offset < arrayBuffer.byteLength - 4) {
                if (dataView.getUint32(offset) === 0x1f43b675) {
                    // Found Cluster, everything before this is headers
                    console.log('Found WebM headers, size:', offset);
                    return arrayBuffer.slice(0, offset);
                }
                offset++;
            }
            console.log('No Cluster found in blob of size:', arrayBuffer.byteLength);
            return null;
        }

        function createCluster(audioData, timestamp) {
            // Convert timestamp to a buffer
            const timecodeBuf = new Uint8Array(2);
            timecodeBuf[0] = (timestamp >> 8) & 0xFF;
            timecodeBuf[1] = timestamp & 0xFF;

            // Create SimpleBlock
            const trackNum = 0x81; // Track 1 in EBML varint
            const simpleBlockHeader = new Uint8Array([
                trackNum,
                timecodeBuf[0],
                timecodeBuf[1],
                0x80  // Flags: Keyframe
            ]);

            // Calculate sizes
            const simpleBlockSize = simpleBlockHeader.length + audioData.byteLength;
            const simpleBlockSizeBuffer = createEBMLSizeBuffer(simpleBlockSize);
            
            // Create cluster
            const clusterTimecodeSize = 2;
            const clusterTimecodeBuffer = createEBMLSizeBuffer(clusterTimecodeSize);
            const clusterSize = 4 + clusterTimecodeBuffer.length + clusterTimecodeSize + 
                               1 + simpleBlockSizeBuffer.length + simpleBlockSize;
            const clusterSizeBuffer = createEBMLSizeBuffer(clusterSize);

            return new Blob([
                // Cluster ID (0x1F43B675)
                new Uint8Array([0x1F, 0x43, 0xB6, 0x75]),
                // Cluster Size
                clusterSizeBuffer,
                // Cluster Timecode ID (0xE7)
                new Uint8Array([0xE7]),
                clusterTimecodeBuffer,
                timecodeBuf,
                // SimpleBlock ID (0xA3)
                new Uint8Array([0xA3]),
                simpleBlockSizeBuffer,
                simpleBlockHeader,
                audioData
            ], { type: 'audio/webm;codecs=opus' });
        }

        function createEBMLSizeBuffer(size) {
            if (size < 0x7F) {
                return new Uint8Array([size | 0x80]);
            } else if (size < 0x3FFF) {
                return new Uint8Array([
                    (size >> 8) | 0x40,
                    size & 0xFF
                ]);
            } else if (size < 0x1FFFFF) {
                return new Uint8Array([
                    (size >> 16) | 0x20,
                    (size >> 8) & 0xFF,
                    size & 0xFF
                ]);
            } else {
                return new Uint8Array([
                    (size >> 24) | 0x10,
                    (size >> 16) & 0xFF,
                    (size >> 8) & 0xFF,
                    size & 0xFF
                ]);
            }
        }

        async function prependWebMHeaders(blob) {
            if (!webmHeaderData) {
                console.log('No WebM headers available, attempting to extract from current blob');
                const headers = await extractWebMHeaders(blob);
                if (headers) {
                    webmHeaderData = headers;
                    console.log('Successfully extracted headers from current blob');
                    clusterStartTime = Date.now();
                }
                return blob;
            }
            
            // For subsequent chunks, create a proper WebM cluster
            const arrayBuffer = await blob.arrayBuffer();
            const timestamp = Math.floor((Date.now() - clusterStartTime) / 20); // Convert to 20ms units
            const cluster = await createCluster(new Uint8Array(arrayBuffer), timestamp);
            
            return new Blob([webmHeaderData, cluster], { type: 'audio/webm;codecs=opus' });
        }

        async function startRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        channelCount: 1,
                        sampleRate: 16000
                    } 
                });

                // Create an audio context to get raw PCM data
                const audioContext = new AudioContext({
                    sampleRate: 16000,
                });
                const source = audioContext.createMediaStreamSource(stream);
                const processor = audioContext.createScriptProcessor(4096, 1, 1);
                
                chunks = [];
                accumulatedTranscription = '';
                lastChunkTime = 0;
                
                processor.onaudioprocess = (e) => {
                    const pcmData = e.inputBuffer.getChannelData(0);
                    // Convert float32 to int16
                    const samples = new Int16Array(pcmData.length);
                    for (let i = 0; i < pcmData.length; i++) {
                        const s = Math.max(-1, Math.min(1, pcmData[i]));
                        samples[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
                    }
                    chunks.push(samples);
                };

                source.connect(processor);
                processor.connect(audioContext.destination);

                // Process chunks every 5 seconds
                recordingInterval = setInterval(async () => {
                    if (chunks.length > 0) {
                        // Combine chunks into one buffer
                        const totalLength = chunks.reduce((acc, chunk) => acc + chunk.length, 0);
                        const combinedBuffer = new Int16Array(totalLength);
                        let offset = 0;
                        for (const chunk of chunks) {
                            combinedBuffer.set(chunk, offset);
                            offset += chunk.length;
                        }
                        
                        const blob = new Blob([combinedBuffer], { type: 'audio/raw' });
                        await sendChunkForProcessing(blob, false);
                        chunks = [];
                    }
                }, 5000);

                // Store cleanup functions
                mediaRecorder = {
                    state: 'recording',
                    stream,
                    audioContext,
                    processor,
                    source,
                    stop: () => {
                        clearInterval(recordingInterval);
                        processor.disconnect();
                        source.disconnect();
                        stream.getTracks().forEach(track => track.stop());
                        audioContext.close();
                        mediaRecorder.state = 'inactive';
                    }
                };

                console.log('Recording started');

            } catch (error) {
                console.error('Error starting recording:', error);
                alert('Error starting recording: ' + error.message);
            }
        }

        async function stopRecording() {
            console.log('Stop button clicked, stopping recording');
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
                
                // Process any remaining audio
                if (chunks.length > 0) {
                    const totalLength = chunks.reduce((acc, chunk) => acc + chunk.length, 0);
                    const combinedBuffer = new Int16Array(totalLength);
                    let offset = 0;
                    for (const chunk of chunks) {
                        combinedBuffer.set(chunk, offset);
                        offset += chunk.length;
                    }
                    
                    const blob = new Blob([combinedBuffer], { type: 'audio/raw' });
                    await sendChunkForProcessing(blob, true);
                    chunks = [];
                }
                
                console.log('Recording stopped');
            }
        }

        async function saveChunkForDebug(blob, status) {
            // Create a new blob with explicit type to ensure proper formatting
            const webmBlob = new Blob([blob], { type: 'audio/webm;codecs=opus' });
            const url = URL.createObjectURL(webmBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `chunk_${debugChunkCounter++}_${status}_${webmBlob.size}bytes.webm`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        async function analyzeWebMChunk(blob, chunkNumber) {
            try {
                // Convert blob to ArrayBuffer for analysis
                const arrayBuffer = await blob.arrayBuffer();
                const dataView = new DataView(arrayBuffer);
                
                // WebM header analysis
                console.log(`\nAnalyzing Chunk ${chunkNumber} (${blob.size} bytes):`);
                console.log('First 16 bytes:', Array.from(new Uint8Array(arrayBuffer.slice(0, 16)))
                    .map(b => b.toString(16).padStart(2, '0'))
                    .join(' '));
                    
                // Check for EBML header (should start with 0x1a 0x45 0xdf 0xa3)
                const hasEBMLHeader = dataView.getUint32(0) === 0x1a45dfa3;
                console.log('Has EBML header:', hasEBMLHeader);
                
                // Basic WebM structure checks
                const checks = {
                    hasEBMLHeader: hasEBMLHeader,
                    size: blob.size,
                    type: blob.type,
                    lastBytes: Array.from(new Uint8Array(arrayBuffer.slice(-8)))
                        .map(b => b.toString(16).padStart(2, '0'))
                        .join(' ')
                };
                
                // Look for key WebM elements
                const knownElements = {
                    EBML: '1a45dfa3',
                    Segment: '18538067',
                    Tracks: '1654ae6b',
                    Audio: 'e1',
                    Cluster: '1f43b675'
                };
                
                const foundElements = {};
                const bytes = new Uint8Array(arrayBuffer);
                let bytesHex = Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
                
                for (const [element, hex] of Object.entries(knownElements)) {
                    foundElements[element] = bytesHex.includes(hex);
                }
                
                console.log('Blob details:', checks);
                console.log('Found WebM elements:', foundElements);
                
                // Additional Opus codec checks
                const codecString = 'OpusHead';
                const textDecoder = new TextDecoder();
                const content = textDecoder.decode(arrayBuffer);
                const hasOpusHeader = content.includes(codecString);
                console.log('Has Opus header:', hasOpusHeader);
                
                // Calculate some basic metrics
                const metrics = {
                    averageByte: bytes.reduce((a, b) => a + b, 0) / bytes.length,
                    zeroBytes: bytes.filter(b => b === 0).length,
                    uniqueBytes: new Set(bytes).size
                };
                console.log('Metrics:', metrics);
                
                return {
                    checks,
                    foundElements,
                    hasOpusHeader,
                    metrics
                };
                
            } catch (error) {
                console.error('Error analyzing WebM chunk:', error);
                return null;
            }
        }

        async function sendChunkForProcessing(blob, isFinal) {
            console.log(`\nSending ${isFinal ? 'final' : 'intermediate'} chunk for processing (${blob.size} bytes)`);
            
            const formData = new FormData();
            formData.append('audio', blob, 'audio.webm');
            formData.append('chunk_time', lastChunkTime.toString());
            formData.append('hash', hash);
            formData.append('doctor', doctor);
            formData.append('is_final_chunk', isFinal.toString());
            
            const maxRetries = 3;
            let retryCount = 0;
            
            while (retryCount < maxRetries) {
                try {
                    const response = await fetch('/transcribe_chunk', {
                        method: 'POST',
                        body: formData
                    });
                    
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    
                    const result = await response.json();
                    console.log('Server response:', result);  // Log full server response
                    
                    if (result.transcription) {
                        console.log('Transcription received:', result.transcription);
                        
                        if (!isFinal) {
                            // Only append if we got new text
                            if (result.transcription.trim()) {
                                accumulatedTranscription += ' ' + result.transcription;
                                const liveTranscript = document.getElementById('liveTranscript');
                                if (liveTranscript) {
                                    liveTranscript.textContent = accumulatedTranscription.trim();
                                    liveTranscript.scrollTop = liveTranscript.scrollHeight;
                                }
                            } else {
                                console.log('Empty transcription received');
                            }
                        } else {
                            const transcriptionResult = document.getElementById('transcriptionResult');
                            if (transcriptionResult) {
                                transcriptionResult.innerHTML = `
                                    <h4>Version ${result.version}</h4>
                                    <p>${result.transcription}</p>
                                `;
                            }
                            const resultDiv = document.getElementById('result');
                            if (resultDiv) {
                                resultDiv.classList.remove('hidden');
                            }
                        }
                    } else {
                        console.log('No transcription in response');
                    }
                    
                    break;
                } catch (error) {
                    retryCount++;
                    console.error(`Error sending chunk (attempt ${retryCount}/${maxRetries}):`, error);
                    
                    if (retryCount === maxRetries) {
                        console.error('Max retries reached, skipping chunk');
                    } else {
                        await new Promise(resolve => setTimeout(resolve, Math.pow(2, retryCount) * 1000));
                    }
                }
            }
            
            if (!isFinal) {
                lastChunkTime += 5000;
            }
        }

        async function generateFinalSummary(fullTranscription) {
            const formData = new FormData();
            formData.append('hash', hash);
            formData.append('doctor', doctor);
            formData.append('prompt', document.getElementById('prompt').value);
            formData.append('model', document.getElementById('llmModel').value);
            formData.append('transcription', fullTranscription);
            
            try {
                const response = await fetch('/generate_summary', {
                    method: 'POST',
                    body: formData
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const result = await response.json();
                document.getElementById('transcriptionResult').innerHTML = `
                    <h4>Version ${result.version}</h4>
                    <details>
                        <summary>Raw Transcript</summary>
                        <p>${result.raw_transcript}</p>
                    </details>
                    <details>
                        <summary>Summary</summary>
                        <p>${result.summary}</p>
                    </details>
                `;
                document.getElementById('result').classList.remove('hidden');
            } catch (error) {
                console.error('Error generating summary:', error);
                alert('Error generating final summary');
            }
        }

        function copyTextFromElement(element) {
            const text = element.innerText || element.textContent;
            navigator.clipboard.writeText(text).then(() => {
                alert('Summary copied to clipboard!');
            }).catch(err => {
                console.error('Failed to copy text: ', err);
            });
        }

        async function retryTranscript(transcription) {
            startProcessingTimer();
            
            const formData = new FormData();
            formData.append('prompt', document.getElementById('prompt').value);
            formData.append('model', document.getElementById('llmModel').value);
            formData.append('hash', hash);
            formData.append('doctor', doctor);
            formData.append('raw_transcript', transcription);
        
            try {
                const response = await fetch('/retry_summary', {
                    method: 'POST',
                    body: formData
                });
        
                const result = await response.json();
                stopProcessingTimer();
        
                document.getElementById('transcriptionResult').innerHTML = `
                    <h4>Version ${result.version}</h4>
                    <details>
                        <summary>Raw Transcript</summary>
                        <p>${result.raw_transcript}</p>
                    </details>
                    <details>
                        <summary>Summary</summary>
                        <p>${result.response}</p>
                    </details>
                `;
                document.getElementById('result').classList.remove('hidden');
                
                // Reload page to show updated previous recordings
                location.reload();
            } catch (error) {
                console.error('Error:', error);
                alert('Error processing transcript');
                stopProcessingTimer();
            }
        }

        async function savePrompt(isDefault) {
            const formData = new FormData();
            formData.append('doctor', doctor);
            formData.append('prompt_text', document.getElementById('prompt').value);
            formData.append('is_default', isDefault);

            try {
                const response = await fetch('/save_prompt', {
                    method: 'POST',
                    body: formData
                });

                if (response.ok) {
                    alert('Prompt saved successfully');
                    location.reload();
                } else {
                    alert('Error saving prompt');
                }
            } catch (error) {
                console.error('Error:', error);
                alert('Error saving prompt');
            }
        }

        function downloadAudio() {
            if (window.lastRecordedAudio) {
                const url = URL.createObjectURL(window.lastRecordedAudio);
                const a = document.createElement('a');
                a.href = url;
                a.download = `recording_${new Date().toISOString()}.wav`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
        }

        function showSaveConfirm() {
            if (confirm('Saving the audio file to the server requires additional patient consent. Have you obtained this consent?')) {
                const formData = new FormData();
                formData.append('audio', window.lastRecordedAudio);
                formData.append('prompt', document.getElementById('prompt').value);
                formData.append('model', document.getElementById('llmModel').value);
                formData.append('hash', hash);
                formData.append('doctor', doctor);
                formData.append('save_audio', true);

                fetch('/transcribe', {
                    method: 'POST',
                    body: formData
                }).then(() => {
                    location.reload();
                }).catch(error => {
                    console.error('Error:', error);
                    alert('Error saving audio');
                });
            }
        }

        function createDebugDiv() {
            const div = document.createElement('div');
            div.id = 'debugInfo';
            div.style.marginTop = '20px';
            div.style.padding = '10px';
            div.style.border = '1px solid #ccc';
            div.innerHTML = '<h4>Debug Information</h4>';
            document.body.appendChild(div);
            return div;
        }
    </script>
</body>
</html>