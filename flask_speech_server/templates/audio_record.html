<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Recorder</title>
    <!-- Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
    <style>
        .recording { color: red; }
        .hidden { display: none; }
        .previous-recording {
            border: 1px solid #dee2e6;
            padding: 0.75rem;
            margin: 0.75rem 0;
            border-radius: 0.375rem;
            background-color: white;
        }
        .prompt-container {
            background-color: #f8f9fa;
            padding: 1rem;
            border-radius: 0.375rem;
            margin: 1rem 0;
            border: 1px solid #dee2e6;
        }
        .record-controls {
            text-align: center;
            margin: 1.5rem 0;
        }
        .record-btn {
            padding: 0.75rem 1.5rem;
            font-size: 1.1rem;
            margin: 0 0.5rem;
        }
        #recordButton {
            background-color: #198754;
            color: white;
        }
        #stopButton {
            background-color: #dc3545;
            color: white;
        }
        .summary-section {
            background-color: white;
            padding: 0.75rem;
            border-radius: 0.375rem;
            border: 1px solid #dee2e6;
            margin-top: 1rem;
        }
        body {
            background-color: #f8f9fa;
            padding: 1rem 0;
            font-size: 0.9rem;
        }
        .session-info {
            background-color: #e9ecef;
            padding: 0.75rem;
            border-radius: 0.375rem;
            margin-bottom: 1rem;
            font-size: 0.9rem;
        }
        h1 { font-size: 1.75rem; }
        h3 { font-size: 1.25rem; }
        h4 { font-size: 1.1rem; }
        .form-control, .form-select {
            padding: 0.375rem 0.5rem;
            font-size: 0.9rem;
        }
        .btn-sm {
            padding: 0.25rem 0.5rem;
            font-size: 0.8rem;
        }
        .chunk-playback {
            margin: 10px 0;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .chunk-playback audio {
            display: block;
            margin-bottom: 5px;
        }
        .chunk-playback a {
            display: inline-block;
            margin-left: 10px;
            font-size: 0.9em;
        }
        .chunk-info {
            margin-bottom: 10px;
            font-family: monospace;
            font-size: 0.9em;
        }
        .chunk-hex {
            font-size: 0.8em;
            background-color: #fff;
            padding: 5px;
            margin: 5px 0;
            border-radius: 3px;
            max-height: 100px;
            overflow-y: auto;
            white-space: pre-wrap;
            word-break: break-all;
        }
        .chunk-playback audio {
            display: block;
            margin: 10px 0;
        }
        .chunk-playback a {
            display: inline-block;
            margin-right: 5px;
        }
        .analysis-section {
            margin: 10px 0;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 4px;
        }
        
        .analysis-section pre {
            max-height: 200px;
            overflow-y: auto;
            font-size: 12px;
        }
    </style>
    <!-- Include marked.js for markdown rendering -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
</head>
<body>
    <div class="container">
        <div class="session-info">
            <h3>Session Info</h3>
            <p class="mb-0"><strong>Doctor:</strong> {{ doctor }}  <strong>Hash:</strong> {{ hash_value }}</p>
        </div>

        <h1 class="text-center mb-3">Audio Recorder</h1>

        <div class="prompt-container">
            <div class="row mb-3">
                <div class="col-md-6">
                    <label for="llmModel" class="form-label">Select LLM Model:</label>
                    <select id="llmModel" class="form-select">
                        {% for model, is_default in llm_models %}
                            <option value="{{ model }}" {% if is_default %}selected{% endif %}>
                                {{ model }}{% if is_default %} (Default){% endif %}
                            </option>
                        {% endfor %}
                    </select>
                </div>
                <div class="col-md-6">
                    <div class="mb-3">
                        <label for="promptSelect" class="form-label">Select Prompt:</label>
                        <select id="promptSelect" class="form-select" onchange="showPromptDetails()">
                            {% for prompt in prompts %}
                                <option value="{{ prompt[1] }}" 
                                        data-id="{{ prompt[0] }}"
                                        data-is-system="{{ prompt[4] }}"
                                        data-is-new="{{ prompt[5] }}"
                                        data-is-default="{{ prompt[2] }}">
                                    (#{{ prompt[0] }})
                                    {% if prompt[2] %}
                                        {% if prompt[4] %}[Sys Def]{% else %}[My Def]{% endif %}
                                    {% endif %}
                                    {% if prompt[5] %}[New!]{% endif %}
                                    {{ prompt[1][:100] }}...
                                </option>
                            {% endfor %}
                        </select>
                    </div>
                </div>

                <div class="mb-3 w-100">
                    <label for="prompt" class="form-label">Prompt Text:</label>
                    <textarea id="prompt" class="form-control" rows="4">{{ prompts[0][1] if prompts else '' }}</textarea>
                    <div class="mt-2 d-flex justify-content-between align-items-center">
                        <div>
                            <button onclick="savePrompt(false)" class="btn btn-primary">Save Changes</button>
                            <button onclick="savePrompt(true)" class="btn btn-outline-primary">Save as Default</button>
                        </div>
                        <div id="promptStatus" class="text-muted small">
                            <!-- Status text will be inserted here -->
                        </div>
                    </div>
                </div>
                
            </div>
        </div>

        <div class="record-controls">
            <button id="recordButton" class="btn record-btn">Start Recording</button>
            <button id="stopButton" class="btn record-btn" disabled>Stop Recording</button>
        </div>

        <div id="result">
            <div class="summary-section">
                <div class="d-flex justify-content-between align-items-center mb-2">
                    <h4 class="mb-0">Summary</h4>
                    <div>
                        <button onclick="copySummary()" class="btn btn-sm btn-primary me-2">Copy Summary</button>
                        <button onclick="retryTranscript(document.querySelector('#result details p').textContent)" class="btn btn-sm btn-outline-secondary">
                            Retry with different settings
                        </button>
                    </div>
                </div>
                <div id="transcriptionResult"></div>
            </div>
        </div>

        <details class="mt-3">
            <summary>Live Transcription</summary>
            <div id="liveTranscript" class="border p-2 mb-3" style="max-height: 150px; overflow-y: auto; font-size: 0.85rem;">
            </div>
        </details>

        <div id="audioOptions" class="text-center mt-2 hidden">
            <div class="previous-recording">
                <p><strong>Audio Options:</strong></p>
                <div class="btn-group">
                    <button onclick="downloadAudio()" class="btn btn-sm btn-outline-secondary">Download Audio</button>
                    <button onclick="showSaveConfirm()" class="btn btn-sm btn-outline-primary">Save to Server</button>
                </div>
            </div>
        </div>

        <div class="text-center mt-2">
            <p id="recordingTimer" class="mb-1">Recording Time: 0s</p>
            <p id="processingTimer" class="hidden mb-1">Processing Time: 0s</p>
            <p id="loading" class="hidden">Loading...</p>
        </div>

        <div id="pendingTranscript" class="mt-3 hidden">
            <div class="alert alert-warning">
                <h5>Pending Transcript</h5>
                <p>A transcript was found that hasn't been summarized yet.</p>
                <div class="pending-content mb-2"></div>
                <button onclick="sendPendingForSummary()" class="btn btn-primary">Generate Summary</button>
            </div>
        </div>

    <div id="previousRecordings">
        <h3>Previous Recordings</h3>
        {% for rec in previous_recordings %}
        <div class="previous-recording">
            <p><strong>Version:</strong> {{ rec[0] }}
                <button onclick="copyTextFromElement(this.closest('.previous-recording').querySelector('.summary-section'))" class="btn btn-sm btn-outline-secondary me-2">
                    Copy Summary
                </button>
                <button 
                    onclick="retryTranscript(`{{ rec[2] | safe | replace('`', '\\`') | replace('\n', '\\n') }}`)"
                    class="retry-btn btn btn-sm btn-outline-secondary"
                >
                    Retry with different settings
                </button>
                <!-- Add audio controls -->
                <div class="audio-controls mt-2">
                    {% if rec[6] %}
                        <!-- Audio is permanently saved -->
                        <button onclick="downloadAudioVersion('{{ hash_value }}', '{{ doctor }}', {{ rec[0] }})" class="btn btn-sm btn-outline-primary">
                            Download Audio
                        </button>
                        <span class="badge bg-success ms-2">Saved to Server</span>
                    {% else %}
                        {% set debug_path = 'debug_audio/' + hash_value + '/' + doctor + '/' + rec[0]|string %}
                        {% if debug_path|exists_dir %}
                            <!-- Audio is in debug storage -->
                            <button onclick="downloadAudioVersion('{{ hash_value }}', '{{ doctor }}', {{ rec[0] }})" class="btn btn-sm btn-outline-secondary">
                                Download Audio
                            </button>
                            <button onclick="saveAudioPermanent('{{ hash_value }}', '{{ doctor }}', {{ rec[0] }})" class="btn btn-sm btn-outline-primary">
                                Save to Server
                            </button>
                            <span class="text-muted ms-2"><small>Debug audio available for 48 hours</small></span>
                        {% endif %}
                    {% endif %}
                </div>
            </p>
            <div class="summary-section">
                {{ rec[3] | markdown | safe }}
            </div>
            <details>
                <summary>Additional Information</summary>
                <p><strong>Date:</strong> {{ rec[5] }}</p>
                <p><strong>Model Used:</strong> {{ rec[4] }}</p>
                <p><strong>Prompt Used:</strong> {{ rec[1] }}</p>
                <details>
                    <summary>Raw Transcript</summary>
                    <p>{{ rec[2] }}</p>
                </details>

                {% if rec[6] %}
                    <p><em>Audio file saved locally</em></p>
                {% endif %}
            </details>
        </div>
        {% endfor %}
    </div>

    </div>

    <!-- Retry Modal -->
    <div class="modal fade" id="retryModal" tabindex="-1" aria-labelledby="retryModalLabel" aria-hidden="true">
        <div class="modal-dialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="retryModalLabel">Retry with Different Settings</h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="mb-3">
                        <label for="retryModel" class="form-label">Select LLM Model:</label>
                        <select id="retryModel" class="form-select">
                            {% for model, is_default in llm_models %}
                                <option value="{{ model }}" {% if is_default %}selected{% endif %}>
                                    {{ model }}{% if is_default %} (Default){% endif %}
                                </option>
                            {% endfor %}
                        </select>
                    </div>
                    <div class="mb-3">
                        <label for="retryPrompt" class="form-label">Select Prompt:</label>
                        <select id="retryPrompt" class="form-select" onchange="updateRetryPromptText()">
                            <option value="custom">Custom Prompt</option>
                            {% for prompt in prompts %}
                                <option value="{{ prompt[0] }}">
                                    #{{ prompt[2] }} - {{ prompt[1][:100] }}...
                                </option>
                            {% endfor %}
                        </select>
                    </div>
                    <div class="mb-3">
                        <label for="retryPromptText" class="form-label">Prompt Text:</label>
                        <textarea id="retryPromptText" class="form-control" rows="4">{{ prompts[0][1] if prompts else 'Enter custom prompt here...' }}</textarea>
                    </div>
                    <input type="hidden" id="retryTranscript" value="">
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Close</button>
                    <button type="button" class="btn btn-primary" onclick="submitRetry()">Submit</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Add this modal after your other modals -->
    <div class="modal fade" id="processingModal" data-bs-backdrop="static" data-bs-keyboard="false" tabindex="-1" aria-labelledby="processingModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-body text-center">
                    <h5 class="mb-3">Processing Your Recording</h5>
                    <div class="progress mb-3">
                        <div id="processingProgress" class="progress-bar progress-bar-striped progress-bar-animated" role="progressbar" style="width: 0%"></div>
                    </div>
                    <p id="processingMessage" class="mb-2"></p>
                    <small class="text-muted">Please wait while we process your recording...</small>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Get URL parameters
        const urlParams = new URLSearchParams(window.location.search);
        const hash = urlParams.get('hash');
        const doctor = urlParams.get('doctor');

        // Audio recording state
        let mediaRecorder = null;
        let recordingChunks = [];
        let chunk_number = 0;
        let recordingInterval = null;
        const RECORDING_INTERVAL = 15000; // 15 seconds
        let recordingTime = 0;
        let timerInterval = null;  // Add new variable to track timer interval specifically
        let pendingRequests = new Set();
        let version = {{ next_version_number }};
        // Debug information
        const DEBUG = true;
        let recordingCompleted = false;

        // Add these to your existing variables
        const funnyMessages = [
            "Teaching AI to understand doctor handwriting...",
            "Consulting with virtual medical board...",
            "Debugging the human condition...",
            "Optimizing healthcare one recording at a time...",
            "Translating medical jargon to English...",
            "Calculating the meaning of life (and medicine)...",
            "Performing digital surgery on your audio...",
            "Consulting with Dr. ChatGPT...",
            "Applying machine learning bandages...",
            "Prescribing ones and zeros...",
        ];

        let processingStartTime;
        let processingModal;
        let progressInterval;

        let promptModal;
        let currentPromptId = null;

        function debugLog(message, data = null) {
            if (DEBUG) {
                console.log(`[${new Date().toISOString()}] ${message}`);
                if (data) console.log('Data:', data);
            }
        }

        async function startRecording() {
            try {
                debugLog('Starting recording...');
                
                // Only increment version if we completed a previous recording
                if (recordingCompleted) {
                    version++;
                    recordingCompleted = false;  // Reset the flag
                }
                
                // Reset chunk number for new recording
                chunk_number = 0;
                
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                let chunks = [];
                
                mediaRecorder = new MediaRecorder(stream);
                
                // Clear previous transcription result if starting a new version
                if (recordingCompleted) {
                    document.getElementById('transcriptionResult').innerHTML = '';
                    document.getElementById('liveTranscript').textContent = '';
                }
                
                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        chunks.push(event.data);
                    }
                };
        
                mediaRecorder.onstop = async () => {
                    debugLog('Recording cycle stopped');
                    if (chunks.length > 0) {
                        const blob = new Blob(chunks, { type: 'audio/webm' });
                        debugLog(`Sending recording, size: ${blob.size} bytes`);
                        await sendChunkToServer(blob, Date.now());
                        chunks = []; // Clear chunks after sending
                    }
                };

                // Start the recording cycle
                debugLog('Starting new recording cycle');
                mediaRecorder.start();
                
                // Set up the interval for stopping and starting recordings
                recordingInterval = setInterval(() => {
                    if (mediaRecorder && mediaRecorder.state === 'recording') {
                        mediaRecorder.stop();
                        mediaRecorder.start();
                    }
                }, RECORDING_INTERVAL);

                // Update UI
                updateRecordingUI(true);
                startRecordingTimer();
                
            } catch (error) {
                console.error('Error starting recording:', error);
                alert('Error starting recording: ' + error.message);
            }
        }

        async function stopRecording() {
            debugLog('Stopping recording...');
            processingStartTime = Date.now();
            
            // Clear recording interval first
            if (recordingInterval) {
                clearInterval(recordingInterval);
                recordingInterval = null;
            }
            
            // Stop the timer
            stopRecordingTimer();
            
            // Stop current recording
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
                mediaRecorder.stream.getTracks().forEach(track => track.stop());
                mediaRecorder = null;
            }
            
            debugLog('Recording stopped');
            updateRecordingUI(false);
            
            try {
                await showProcessingModal();
                
                // Wait for all pending requests to complete
                await Promise.allSettled(Array.from(pendingRequests));
                
                // Add a delay to ensure the final chunk is processed
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                // Check chunks with timeout
                const MAX_WAIT_TIME = 30000; // 30 seconds
                const START_TIME = Date.now();
                let allProcessed = false;
                
                while (Date.now() - START_TIME < MAX_WAIT_TIME && !allProcessed) {
                    try {
                        const response = await fetch(`/check_chunks_processed?hash=${encodeURIComponent(hash)}&doctor=${encodeURIComponent(doctor)}&version=${version}&final_chunk=${chunk_number - 1}`);
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        const data = await response.json();
                        allProcessed = data.all_processed;
                        
                        if (!allProcessed) {
                            await new Promise(resolve => setTimeout(resolve, 1000)); // Wait 1 second before next check
                        }
                    } catch (error) {
                        console.error('Error checking chunks:', error);
                        break;
                    }
                }
                
                if (!allProcessed) {
                    throw new Error('Timeout waiting for chunks to process');
                }

                // Rest of the processing...
                debugLog('Fetching final transcription from server...');
                const response = await fetch(`/get_transcription?hash=${encodeURIComponent(hash)}&doctor=${encodeURIComponent(doctor)}&version=${version}`);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                const fullTranscription = data.transcription;
                
                if (fullTranscription) {
                    debugLog('Generating final summary...');
                    await generateFinalSummary(fullTranscription);
                    recordingCompleted = true;
                    
                    // Record processing time
                    const processingTime = Date.now() - processingStartTime;
                    await fetch('/record_processing_time', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/x-www-form-urlencoded',
                        },
                        body: `hash=${encodeURIComponent(hash)}&doctor=${encodeURIComponent(doctor)}&version=${version}&processing_time=${processingTime}`
                    });
                    
                    // Hide modal after completion
                    if (progressInterval) {
                        clearInterval(progressInterval);
                    }
                    const progressBar = document.getElementById('processingProgress');
                    if (progressBar) {
                        progressBar.style.width = '100%';
                    }
                    setTimeout(() => {
                        if (processingModal) {
                            processingModal.hide();
                        }
                    }, 500);
                } else {
                    throw new Error('No transcription data received');
                }
                
            } catch (error) {
                console.error('Error in stopRecording:', error);
                if (processingModal) {
                    processingModal.hide();
                }
                alert('Error processing recording. Some data may have been lost. Please try again.');
            }
        }

        async function sendChunkToServer(audioBlob, timestamp) {
            const MAX_RETRIES = 3;
            const RETRY_DELAY = 1000; // 1 second
            let attempts = 0;

            const formData = new FormData();
            formData.append('audio', audioBlob);
            formData.append('chunk_number', chunk_number.toString());
            formData.append('hash', hash);
            formData.append('doctor', doctor);
            formData.append('version', version);
            
            debugLog(`Sending chunk ${chunk_number} to server (size: ${audioBlob.size} bytes)`);
            chunk_number++;

            while (attempts < MAX_RETRIES) {
                try {
                    const requestPromise = fetch('/transcribe_chunk', {
                        method: 'POST',
                        body: formData
                    }).then(async response => {
                        if (!response.ok) {
                            const errorText = await response.text();
                            throw new Error(`HTTP error! status: ${response.status}, message: ${errorText}`);
                        }
                        const result = await response.json();
                        debugLog(`Received transcription for chunk ${chunk_number - 1}:`, result);
                        
                        if (result.transcription) {
                            updateTranscriptionUI(result.transcription);
                        }

                        if (result.error) {
                            console.log(result.error)
                        }
                        
                        pendingRequests.delete(requestPromise);
                    }).catch(error => {
                        debugLog(`Error processing chunk ${chunk_number - 1}:`, error);
                        pendingRequests.delete(requestPromise);
                        throw error;
                    });
                    
                    pendingRequests.add(requestPromise);
                    return; // Success, exit the retry loop
                    
                } catch (error) {
                    attempts++;
                    debugLog(`Attempt ${attempts} failed for chunk ${chunk_number - 1}:`, error);
                    
                    if (attempts === MAX_RETRIES) {
                        debugLog(`All retry attempts failed for chunk ${chunk_number - 1}`);
                        updateTranscriptionUI(" [Connection error - some audio may be lost] ");
                    } else {
                        debugLog(`Retrying in ${RETRY_DELAY}ms...`);
                        await new Promise(resolve => setTimeout(resolve, RETRY_DELAY));
                    }
                }
            }
        }

        function updateTranscriptionUI(text) {
            const transcriptElement = document.getElementById('liveTranscript');
            if (transcriptElement) {
                transcriptElement.textContent += ' ' + text;
                transcriptElement.scrollTop = transcriptElement.scrollHeight;
            }
        }

        function updateRecordingUI(isRecording) {
            const startButton = document.getElementById('recordButton');
            const stopButton = document.getElementById('stopButton');
            if (startButton) startButton.disabled = isRecording;
            if (stopButton) stopButton.disabled = !isRecording;
        }

        function startRecordingTimer() {
            recordingTime = 0;  // Reset the time when starting
            const timerDisplay = document.getElementById('recordingTimer');
            
            if (timerInterval) {
                clearInterval(timerInterval);
                console.log('[startRecordingTimer] Cleared existing timer interval');
            }
            
            timerInterval = setInterval(() => {
                recordingTime++;
                if (timerDisplay) {
                    timerDisplay.textContent = `Recording: ${recordingTime}s`;
                    console.log('[Timer Interval] Updated timer UI to:', recordingTime, 's');
                }
            }, 1000);
            console.log('[startRecordingTimer] Started new timer interval:', timerInterval);
        }

        function stopRecordingTimer() {
            console.log('[stopRecordingTimer] Attempting to stop timer...');
            console.log('[stopRecordingTimer] Current timer interval:', timerInterval);
            
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
                console.log('[stopRecordingTimer] Cleared and nulled timer interval');
            }
            
            const timerDisplay = document.getElementById('recordingTimer');
            if (timerDisplay) {
                timerDisplay.textContent = `Recording Time: ${recordingTime}s`;
                console.log('[stopRecordingTimer] Final timer UI update:', recordingTime, 's');
            }
        }

        function startProcessingTimer() {
            processingTime = 0;
            document.getElementById('processingTimer').classList.remove('hidden');
            document.getElementById('processingTimer').textContent = `Processing Time: ${processingTime}s`;
            processingTimerInterval = setInterval(() => {
                processingTime++;
                document.getElementById('processingTimer').textContent = `Processing Time: ${processingTime}s`;
            }, 1000);
        }

        function stopProcessingTimer() {
            clearInterval(processingTimerInterval);
            document.getElementById('processingTimer').textContent = `Processing Time: ${processingTime}s`;
        }

        function stopTimers() {
            clearInterval(recordingInterval);
            clearInterval(processingTimerInterval);
        }

        function updatePromptText() {
            const select = document.getElementById('promptSelect');
            const promptArea = document.getElementById('prompt');
            if (select.value === 'custom') {
                promptArea.value = '';
                promptArea.removeAttribute('readonly');
            } else {
                promptArea.value = select.value;
                promptArea.setAttribute('readonly', true);
            }
        }

        async function generateFinalSummary(fullTranscription) {
            debugLog('Starting generateFinalSummary with transcription:', fullTranscription);
            
            const formData = new FormData();
            formData.append('hash', hash);
            formData.append('doctor', doctor);
            formData.append('prompt', document.getElementById('prompt').value);
            formData.append('model', document.getElementById('llmModel').value);
            formData.append('transcription', fullTranscription);
            
            try {
                debugLog('Sending request to /generate_summary');
                const response = await fetch('/generate_summary', {
                    method: 'POST',
                    body: formData
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    throw new Error(`HTTP error! status: ${response.status}, message: ${errorText}`);
                }
                
                debugLog('Received response from /generate_summary');
                const result = await response.json();
                debugLog('Parsed response:', result);
                
                document.getElementById('transcriptionResult').innerHTML = `
                    <div class="mt-2">
                        ${marked.parse(result.summary)}
                    </div>
                    <details>
                        <summary>Raw Transcript</summary>
                        <p class="mt-2">${result.raw_transcript}</p>
                    </details>
                `;
                document.getElementById('result').classList.remove('hidden');
                debugLog('Summary UI updated successfully');
                
            } catch (error) {
                console.error('Error in generateFinalSummary:', error);
                alert('Error generating final summary: ' + error.message);
            }
        }

        function copySummary() {
            const transcriptionResult = document.getElementById('transcriptionResult');
            // Get only the first div with class mt-2 which contains the summary
            const summaryDiv = transcriptionResult.querySelector('.mt-2');
            if (!summaryDiv) return;
            
            // Create a temporary element to hold the HTML content
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = summaryDiv.innerHTML;
            
            // Write both HTML and plain text to clipboard
            const clipboardData = new ClipboardItem({
                'text/plain': new Blob([summaryDiv.innerText], { type: 'text/plain' }),
                'text/html': new Blob([tempDiv.innerHTML], { type: 'text/html' })
            });
            
            navigator.clipboard.write([clipboardData]).then(() => {
                // Create or get toast notification
                let toast = document.getElementById('copyToast');
                if (!toast) {
                    toast = document.createElement('div');
                    toast.id = 'copyToast';
                    toast.style.cssText = `
                        position: fixed;
                        bottom: 20px;
                        right: 20px;
                        background: rgba(0,0,0,0.8);
                        color: white;
                        padding: 10px 20px;
                        border-radius: 5px;
                        z-index: 1000;
                        transition: opacity 0.3s;
                    `;
                    document.body.appendChild(toast);
                }
                
                // Show toast
                toast.textContent = 'Summary copied to clipboard';
                toast.style.opacity = '1';
                
                // Hide toast after 2 seconds
                setTimeout(() => {
                    toast.style.opacity = '0';
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy text: ', err);
            });
        }

        function copyTextFromElement(element) {
            // Find the first paragraph in the summary section
            const summaryDiv = element.querySelector('.summary-section');
            if (!summaryDiv) return;
            
            // Create a temporary element to hold the HTML content
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = summaryDiv.innerHTML;
            
            // Write both HTML and plain text to clipboard
            const clipboardData = new ClipboardItem({
                'text/plain': new Blob([summaryDiv.innerText], { type: 'text/plain' }),
                'text/html': new Blob([tempDiv.innerHTML], { type: 'text/html' })
            });
            
            navigator.clipboard.write([clipboardData]).then(() => {
                // Create or get toast notification
                let toast = document.getElementById('copyToast');
                if (!toast) {
                    toast = document.createElement('div');
                    toast.id = 'copyToast';
                    toast.style.cssText = `
                        position: fixed;
                        bottom: 20px;
                        right: 20px;
                        background: rgba(0,0,0,0.8);
                        color: white;
                        padding: 10px 20px;
                        border-radius: 5px;
                        z-index: 1000;
                        transition: opacity 0.3s;
                    `;
                    document.body.appendChild(toast);
                }
                
                // Show toast
                toast.textContent = 'Summary copied to clipboard';
                toast.style.opacity = '1';
                
                // Hide toast after 2 seconds
                setTimeout(() => {
                    toast.style.opacity = '0';
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy text: ', err);
            });
        }

        function showRetryModal(transcript) {
            document.getElementById('retryTranscript').value = transcript;
            const modal = new bootstrap.Modal(document.getElementById('retryModal'));
            modal.show();
        }

        function updateRetryPromptText() {
            const select = document.getElementById('retryPrompt');
            const textarea = document.getElementById('retryPromptText');
            if (select.value === 'custom') {
                textarea.value = '';
            } else {
                textarea.value = select.value;
            }
        }

        async function submitRetry() {
            // Show loading state
            const submitButton = document.querySelector('#retryModal .modal-footer .btn-primary');
            const originalText = submitButton.textContent;
            submitButton.disabled = true;
            submitButton.innerHTML = '<span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>Loading...';
            
            const transcript = document.getElementById('retryTranscript').value;
            const model = document.getElementById('retryModel').value;
            const prompt = document.getElementById('retryPromptText').value;
            
            try {
                // Increment version number
                version++;
                
                const formData = new FormData();
                formData.append('hash', hash);
                formData.append('doctor', doctor);
                formData.append('prompt', prompt);
                formData.append('model', model);
                formData.append('transcription', transcript);

                const response = await fetch('/generate_summary', {
                    method: 'POST',
                    body: formData
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                // Hide modal
                bootstrap.Modal.getInstance(document.getElementById('retryModal')).hide();
                
                // Show loading overlay
                const overlay = document.createElement('div');
                overlay.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(255, 255, 255, 0.8);
                    display: flex;
                    justify-content: center;
                    align-items: center;
                    z-index: 9999;
                `;
                overlay.innerHTML = `
                    <div class="text-center">
                        <div class="spinner-border text-primary mb-2" role="status"></div>
                        <div>Generating new summary...</div>
                    </div>
                `;
                document.body.appendChild(overlay);
                
                // Reload page to show new version and scroll to top
                location.reload();
                
            } catch (error) {
                console.error('Error:', error);
                alert('Error generating new summary: ' + error.message);
                
                // Reset button state
                submitButton.disabled = false;
                submitButton.textContent = originalText;
            }
        }

        // Update the existing retry button onclick handler
        function retryTranscript(transcript) {
            showRetryModal(transcript);
        }

        async function savePrompt(setDefault) {
            const promptText = document.getElementById('prompt').value;
            const doctor = '{{ doctor }}';
            
            try {
                const response = await fetch('/save_prompt', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: new URLSearchParams({
                        doctor: doctor,
                        prompt_text: promptText,
                        prompt_id: currentPromptId,
                        set_default: setDefault
                    })
                });
                
                const data = await response.json();
                if (response.ok) {
                    // Update the prompts list
                    updatePromptsList(data.prompts);
                    showAlert('success', 'Prompt saved successfully');
                } else {
                    showAlert('error', data.error);
                }
            } catch (error) {
                showAlert('error', 'Failed to save prompt');
            }
        }

        function downloadAudio() {
            if (window.lastRecordedAudio) {
                const url = URL.createObjectURL(window.lastRecordedAudio);
                const a = document.createElement('a');
                a.href = url;
                a.download = `recording_${new Date().toISOString()}.wav`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
        }

        function showSaveConfirm() {
            if (confirm('Saving the audio file to the server requires additional patient consent. Have you obtained this consent?')) {
                const formData = new FormData();
                formData.append('audio', window.lastRecordedAudio);
                formData.append('prompt', document.getElementById('prompt').value);
                formData.append('model', document.getElementById('llmModel').value);
                formData.append('hash', hash);
                formData.append('doctor', doctor);
                formData.append('save_audio', true);

                fetch('/transcribe', {
                    method: 'POST',
                    body: formData
                }).then(() => {
                    location.reload();
                }).catch(error => {
                    console.error('Error:', error);
                    alert('Error saving audio');
                });
            }
        }

        function createDebugDiv() {
            const div = document.createElement('div');
            div.id = 'debugInfo';
            div.style.marginTop = '20px';
            div.style.padding = '10px';
            div.style.border = '1px solid #ccc';
            div.innerHTML = '<h4>Debug Information</h4>';
            document.body.appendChild(div);
            return div;
        }

        // Add these utility functions
        function hexDump(buffer, offset = 0, length = 32) {
            const view = new Uint8Array(buffer);
            const hex = Array.from(view.slice(offset, offset + length))
                .map(b => b.toString(16).padStart(2, '0'))
                .join(' ');
            const ascii = Array.from(view.slice(offset, offset + length))
                .map(b => b >= 32 && b <= 126 ? String.fromCharCode(b) : '.')
                .join('');
            return `${hex}\n${ascii}`;
        }

        function analyzeWebMElement(dataView, offset) {
            const id = dataView.getUint32(offset);
            let size = 0;
            let sizeLength = 0;
            
            // Determine size length from first byte
            const firstByte = dataView.getUint8(offset + 4);
            if (firstByte & 0x80) sizeLength = 1;
            else if (firstByte & 0x40) sizeLength = 2;
            else if (firstByte & 0x20) sizeLength = 3;
            else if (firstByte & 0x10) sizeLength = 4;
            
            // Read size
            for (let i = 0; i < sizeLength; i++) {
                size = (size << 8) | dataView.getUint8(offset + 4 + i);
            }
            
            return {
                id,
                size,
                headerLength: 4 + sizeLength,
                totalLength: 4 + sizeLength + size
            };
        }

        // Add event listeners when the document loads
        document.addEventListener('DOMContentLoaded', function() {
            // Connect record button
            const recordButton = document.getElementById('recordButton');
            const stopButton = document.getElementById('stopButton');
            
            if (recordButton) {
                recordButton.addEventListener('click', startRecording);
                debugLog('Record button listener added');
            }
            
            if (stopButton) {
                stopButton.addEventListener('click', stopRecording);
                debugLog('Stop button listener added');
            }

            showPromptDetails();
            checkPendingTranscripts();
        });

        function showPromptDetails() {
            const select = document.getElementById('promptSelect');
            const option = select.selectedOptions[0];
            const promptText = document.getElementById('prompt');
            const statusDiv = document.getElementById('promptStatus');
            
            currentPromptId = option.dataset.id;
            // Set the full text from the option's value
            promptText.value = select.value;
            
            // Update status text
            let status = [];
            if (option.dataset.isSystem === 'True') {
                status.push('Changes will create a new personal prompt');
            }
            if (option.dataset.isDefault === 'True') {
                if (option.dataset.isSystem === 'True') {
                    status.push('Current system default');
                } else {
                    status.push('Current personal default');
                }
            }
            
            statusDiv.textContent = status.join(' • ');
        }

        function updatePromptsList(prompts) {
            const select = document.getElementById('promptSelect');
            select.innerHTML = '';
            
            prompts.forEach(prompt => {
                const option = document.createElement('option');
                option.value = prompt[1];  // Full prompt text as value
                option.dataset.id = prompt[0];
                option.dataset.isSystem = prompt[4];
                option.dataset.isNew = prompt[5];
                option.dataset.isDefault = prompt[2];
                
                let label = `(#${prompt[0]})`;
                if (prompt[2]) {
                    if (prompt[4]) {
                        label += ' [System Default]';
                    } else {
                        label += ' [My Default]';
                    }
                }
                if (prompt[5]) label += ' [New!]';
                label += ' ' + prompt[1].substring(0, 100) + '...';
                
                option.textContent = label;
                select.appendChild(option);
            });
            
            showPromptDetails();
        }

        async function downloadAudioVersion(hash, doctor, version) {
            try {
                const response = await fetch(`/download_audio/${hash}/${doctor}/${version}`);
                if (!response.ok) {
                    throw new Error('Download failed');
                }
                
                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `recording_${hash}_${doctor}_v${version}.webm`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                window.URL.revokeObjectURL(url);
            } catch (error) {
                console.error('Error downloading audio:', error);
                alert('Error downloading audio file');
            }
        }

        async function saveAudioPermanent(hash, doctor, version) {
            if (!confirm('Saving the audio file permanently requires patient consent. Continue?')) {
                return;
            }

            try {
                const response = await fetch('/save_audio_permanent', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/x-www-form-urlencoded',
                    },
                    body: `hash=${encodeURIComponent(hash)}&doctor=${encodeURIComponent(doctor)}&version=${version}`
                });

                if (!response.ok) {
                    throw new Error('Save failed');
                }

                // Reload the page to show updated status
                location.reload();
            } catch (error) {
                console.error('Error saving audio:', error);
                alert('Error saving audio file permanently');
            }
        }

        async function showProcessingModal() {
            try {
                // Check if modal exists and initialize if needed
                if (!processingModal) {
                    const modalElement = document.getElementById('processingModal');
                    if (!modalElement) {
                        console.error('Processing modal element not found');
                        return;
                    }
                    processingModal = new bootstrap.Modal(modalElement, {
                        backdrop: 'static',
                        keyboard: false
                    });
                }

                // Use hardcoded messages as fallback if server fetch fails
                let funnyMessages = [
                    "Processing your recording...",
                    "Almost there...",
                    "Working on it..."
                ];

                try {
                    const quotesResponse = await fetch('/get_funny_quotes');
                    const quotesData = await quotesResponse.json();
                    if (quotesData.quotes && quotesData.quotes.length > 0) {
                        funnyMessages = quotesData.quotes;
                    }
                } catch (error) {
                    console.error('Error fetching quotes:', error);
                    // Continue with fallback messages
                }

                const response = await fetch('/get_average_processing_time');
                const data = await response.json();
                const expectedDuration = data.average_time;
                
                const progressBar = document.getElementById('processingProgress');
                const messageElement = document.getElementById('processingMessage');
                
                let progress = 0;
                progressBar.style.width = '0%';
                messageElement.textContent = funnyMessages[Math.floor(Math.random() * funnyMessages.length)];
                
                processingModal.show();
                
                // Clear any existing interval
                if (progressInterval) {
                    clearInterval(progressInterval);
                }
                
                // Update progress bar
                const updateInterval = 100; // Update every 100ms
                const incrementPerUpdate = (updateInterval / expectedDuration) * 100;
                
                progressInterval = setInterval(() => {
                    progress = Math.min(progress + incrementPerUpdate, 99);
                    progressBar.style.width = `${progress}%`;
                    
                    // Change message at 50% progress
                    if (Math.floor(progress) === 50) {
                        messageElement.textContent = funnyMessages[Math.floor(Math.random() * funnyMessages.length)];
                    }
                }, updateInterval);
            } catch (error) {
                console.error('Error in showProcessingModal:', error);
                alert('Processing your recording... Please wait.');
            }
        }

        async function checkPendingTranscripts() {
            try {
                const response = await fetch(`/check_pending_transcripts?hash=${encodeURIComponent(hash)}&doctor=${encodeURIComponent(doctor)}`);
                const data = await response.json();
                
                if (data.has_pending) {
                    const pendingDiv = document.getElementById('pendingTranscript');
                    pendingDiv.classList.remove('hidden');
                    pendingDiv.querySelector('.pending-content').textContent = data.transcript;
                    window.pendingVersion = data.version;
                    window.pendingTranscript = data.transcript;
                }
            } catch (error) {
                console.error('Error checking pending transcripts:', error);
            }
        }

        async function sendPendingForSummary() {
            if (!window.pendingTranscript) return;
            
            try {
                const formData = new FormData();
                formData.append('hash', hash);
                formData.append('doctor', doctor);
                formData.append('prompt', document.getElementById('prompt').value);
                formData.append('model', document.getElementById('llmModel').value);
                formData.append('transcription', window.pendingTranscript);
                
                const response = await fetch('/generate_summary', {
                    method: 'POST',
                    body: formData
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const result = await response.json();
                
                // Update UI with the summary
                document.getElementById('transcriptionResult').innerHTML = `
                    <div class="mt-2">
                        ${marked.parse(result.summary)}
                    </div>
                    <details>
                        <summary>Raw Transcript</summary>
                        <p class="mt-2">${result.raw_transcript}</p>
                    </details>
                `;
                document.getElementById('result').classList.remove('hidden');
                
                // Hide pending transcript section
                document.getElementById('pendingTranscript').classList.add('hidden');
                
                // Update version number
                version = result.version;
                recordingCompleted = true;
                
                // Clear pending data
                window.pendingVersion = null;
                window.pendingTranscript = null;
                
                // Reload page to show updated version in previous recordings
                location.reload();
                
            } catch (error) {
                console.error('Error generating summary:', error);
                alert('Error generating summary: ' + error.message);
            }
        }
    </script>
</body>
</html>